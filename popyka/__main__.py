import abc
import json
import logging
import os
from urllib.parse import urlparse

import psycopg2.extras
from confluent_kafka import Producer
from psycopg2.extensions import connection as Connection
from psycopg2.extras import ReplicationCursor

logger = logging.getLogger(__name__)


# Kinda public API


class Wal2JsonV2Change(dict):
    """Represent a change generated by wal2json using format version 2"""

    # TODO: use class or dataclass, to make API more clear and easier for implementations of `Processors`


class Processor(abc.ABC):
    """Base class for processors of changes"""

    # FIXME: this is pretty awful, name and design.
    # TODO: Implement error handling, retries, etc.

    def process_change(self, change: Wal2JsonV2Change):
        """Receives a change and process it."""
        raise NotImplementedError()


# Processors implementations


class DumpToStdOutProcessor(Processor):
    """Processor that dumps the payload"""

    def process_change(self, change: Wal2JsonV2Change):
        # TODO: make json.dumps() lazy
        logger.debug("DumpToStdOutProcessor: change: %s", json.dumps(change, indent=4))


class ProduceToKafkaProcessor(Processor):
    @staticmethod
    def _get_conf() -> dict:
        return json.loads(os.environ.get("KAFKA_CONF_DICT"))

    def __init__(self):
        self._producer = Producer(self._get_conf())

    def process_change(self, change: Wal2JsonV2Change):
        self._producer.produce(topic="popyka", value=json.dumps(change))
        self._producer.flush()
        logger.info("Message produced to Kafka was flush()'ed")


# Adaptor, is invoked by psycopg2, it runs one by one the configured `Processors`


class ReplicationConsumerToProcessorAdaptor:
    """Psycopg2 replication consumer that runs configured PoPyKa Processors on the received changes"""

    def __init__(self, processors: list[Processor]):
        self._processors = processors

    def __call__(self, msg: psycopg2.extras.ReplicationMessage):
        logger.info("ConsumerRunProcessors: received payload: %s", msg)
        change = Wal2JsonV2Change(json.loads(msg.payload))
        for processor in self._processors:
            processor.process_change(change)

        # Flush after every message is successfully processed
        msg.cursor.send_feedback(flush_lsn=msg.data_start)


# Main class


class Main:
    def get_processors(self) -> list[Processor]:
        # TODO: take class name of processors from env
        return [DumpToStdOutProcessor(), ProduceToKafkaProcessor()]

    def get_slot_name(self) -> str:
        # TODO: let user overwrite via env variables
        _, _, db = self.get_dsn()
        return f"popyka_{db}"

    def get_connection(self) -> Connection:
        # https://www.postgresql.org/docs/current/libpq-connect.html#LIBPQ-CONNSTRING
        dsn, parsed, db = self.get_dsn()
        logger.info("DSN host=%s port=%s user=%s db=%s", parsed.hostname, parsed.port, parsed.username, db)
        return psycopg2.connect(dsn, connection_factory=psycopg2.extras.LogicalReplicationConnection)

    def get_dsn(self) -> tuple[str, object, str]:
        """Return DSN, also parsed URI and database name"""
        dsn = os.environ.get("DSN")
        parsed = urlparse(dsn)
        assert parsed.path.startswith("/")
        return dsn, parsed, parsed.path[1:]

    def main(self):
        adaptor = ReplicationConsumerToProcessorAdaptor(self.get_processors())
        cn = self.get_connection()
        slot_name = self.get_slot_name()

        with cn.cursor() as cur:
            cur: ReplicationCursor
            try:
                cur.create_replication_slot(slot_name, output_plugin="wal2json")
                logger.info("Replication slot %s created", slot_name)
            except psycopg2.errors.DuplicateObject:
                logger.info("Replication slot %s already exists", slot_name)

            cur.start_replication(slot_name=slot_name, decode=True, options={"format-version": "2"})
            cur.consume_stream(adaptor)


if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO)
    Main().main()
